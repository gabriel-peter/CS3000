\documentclass[11pt]{article}

\newcommand{\yourname}{Gabriel Peter}
\newcommand{\yourcollaborators}{}

\def\comments{0}

%format and packages

%\usepackage{algorithm, algorithmic}
\usepackage{algpseudocode}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{enumerate}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{framed}
\usepackage{verbatim}
\usepackage[margin=1.0in]{geometry}
\usepackage{microtype}
\usepackage{kpfonts}
\usepackage{palatino}
	\DeclareMathAlphabet{\mathtt}{OT1}{cmtt}{m}{n}
	\SetMathAlphabet{\mathtt}{bold}{OT1}{cmtt}{bx}{n}
	\DeclareMathAlphabet{\mathsf}{OT1}{cmss}{m}{n}
	\SetMathAlphabet{\mathsf}{bold}{OT1}{cmss}{bx}{n}
	\renewcommand*\ttdefault{cmtt}
	\renewcommand*\sfdefault{cmss}
	\renewcommand{\baselinestretch}{1.06}
\usepackage[usenames,dvipsnames]{xcolor}
\definecolor{DarkGreen}{rgb}{0.15,0.5,0.15}
\definecolor{DarkRed}{rgb}{0.6,0.2,0.2}
\definecolor{DarkBlue}{rgb}{0.2,0.2,0.6}
\definecolor{DarkPurple}{rgb}{0.4,0.2,0.4}
\usepackage[pdftex]{hyperref}
\usepackage{circuitikz}
\hypersetup{
	linktocpage=true,
	colorlinks=true,				% false: boxed links; true: colored links
	linkcolor=DarkBlue,		% color of internal links
	citecolor=DarkBlue,	% color of links to bibliography
	urlcolor=DarkBlue,		% color of external links
}

\usepackage[boxruled,vlined,nofillcomment]{algorithm2e}
	\SetKwProg{Fn}{Function}{\string:}{}
	\SetKwFor{While}{While}{}{}
	\SetKwFor{For}{For}{}{}
	\SetKwIF{If}{ElseIf}{Else}{If}{:}{ElseIf}{Else}{:}
	\SetKw{Return}{Return}
	

%enclosure macros
\newcommand{\paren}[1]{\ensuremath{\left( {#1} \right)}}
\newcommand{\bracket}[1]{\ensuremath{\left\{ {#1} \right\}}}
\renewcommand{\sb}[1]{\ensuremath{\left[ {#1} \right\]}}
\newcommand{\ab}[1]{\ensuremath{\left\langle {#1} \right\rangle}}

%probability macros
\newcommand{\ex}[2]{{\ifx&#1& \mathbb{E} \else \underset{#1}{\mathbb{E}} \fi \left[#2\right]}}
\newcommand{\pr}[2]{{\ifx&#1& \mathbb{P} \else \underset{#1}{\mathbb{P}} \fi \left[#2\right]}}
\newcommand{\var}[2]{{\ifx&#1& \mathrm{Var} \else \underset{#1}{\mathrm{Var}} \fi \left[#2\right]}}


%useful CS macros
\newcommand{\poly}{\mathrm{poly}}
\newcommand{\polylog}{\mathrm{polylog}}
\newcommand{\zo}{\{0,1\}}
\newcommand{\pmo}{\{\pm1\}}

\newcommand{\getsr}{\gets_{\mbox{\tiny R}}}
\newcommand{\card}[1]{\left| #1 \right|}
\newcommand{\set}[1]{\left\{#1\right\}}
\newcommand{\negl}{\mathrm{negl}}
\newcommand{\eps}{\varepsilon}
\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\argmax}{arg\,max}
\newcommand{\eqand}{\qquad \textrm{and} \qquad}
\newcommand{\ind}[1]{\mathbb{I}\{#1\}}
\newcommand{\sslash}{\ensuremath{\mathbin{/\mkern-3mu/}}}

%mathbb
\newcommand{\N}{\mathbb{N}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Z}{\mathbb{Z}}
%mathcal
\newcommand{\cA}{\mathcal{A}}
\newcommand{\cB}{\mathcal{B}}
\newcommand{\cC}{\mathcal{C}}
\newcommand{\cD}{\mathcal{D}}
\newcommand{\cE}{\mathcal{E}}
\newcommand{\cF}{\mathcal{F}}
\newcommand{\cL}{\mathcal{L}}
\newcommand{\cM}{\mathcal{M}}
\newcommand{\cO}{\mathcal{O}}
\newcommand{\cP}{\mathcal{P}}
\newcommand{\cQ}{\mathcal{Q}}
\newcommand{\cR}{\mathcal{R}}
\newcommand{\cS}{\mathcal{S}}
\newcommand{\cU}{\mathcal{U}}
\newcommand{\cV}{\mathcal{V}}
\newcommand{\cW}{\mathcal{W}}
\newcommand{\cX}{\mathcal{X}}
\newcommand{\cY}{\mathcal{Y}}
\newcommand{\cZ}{\mathcal{Z}}

%theorem macros
\newtheorem{thm}{Theorem}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{fact}[thm]{Fact}
\newtheorem{clm}[thm]{Claim}
\newtheorem{rem}[thm]{Remark}
\newtheorem{coro}[thm]{Corollary}
\newtheorem{prop}[thm]{Proposition}
\newtheorem{conj}[thm]{Conjecture}

\theoremstyle{definition}
\newtheorem{defn}[thm]{Definition}

\usepackage{mathtools}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}


\newcommand{\instructor}{Drew van der Poel}
\newcommand{\hwnum}{2}
\newcommand{\hwdue}{Friday, May 28 at 11:59pm via \href{https://gradescope.com/courses/266585}{Gradescope}}

\theoremstyle{theorem}
\newtheorem{prob}{Problem}
\newtheorem{sol}{Solution}

\definecolor{cit}{rgb}{0.05,0.2,0.45} 
\newcommand{\solution}{\medskip\noindent{\color{DarkBlue}\textbf{Solution:}}}

\begin{document}
{\Large 
\begin{center}{CS3000: Algorithms \& Data} --- Summer I '21 --- \instructor \end{center}}
{\large
\vspace{10pt}
\noindent Homework~\hwnum \vspace{2pt}\\
Due~\hwdue}

\bigskip
{\large
\noindent Name: \yourname \vspace{2pt}\\ Collaborators: \yourcollaborators}

\vspace{15pt}
\begin{itemize}

\item Make sure to put your name on the first page.  If you are using the \LaTeX~template we provided, then you can make sure it appears by filling in the \texttt{yourname} command.

\item This assignment is due~\hwdue.  No late assignments will be accepted.  Make sure to submit something before the deadline.

\item Solutions must be typeset.  If you need to draw any diagrams, you may draw them by hand as long as they are embedded in the PDF.  I recommend using the source file for this assignment to get started.

\item I encourage you to work with your classmates on the homework problems. \emph{If you do collaborate, you must write all solutions by yourself, in your own words.}  Do not submit anything you cannot explain.  Please list all your collaborators in your solution for each problem by filling in the \texttt{yourcollaborators} command.

\item Finding solutions to homework problems on the web, or by asking students not enrolled in the class is strictly forbidden.

\end{itemize}



\newpage

\begin{prob}Improve the MBTA (18 points) \end{prob}
You have been commissioned to design a new bus system that will run along Huntington Avenue.  The bus system must provide service to $n$ stops on the eastbound route.  Commuters may begin their trip at any stop $i$ and end at any other step $j > i$.  Here are some na\"ive ways to design the system:
\begin{enumerate}
\item You can have a bus run from the western-most point to the eastern-most point making all $n$ stops. The system would be cheap because it only requires $n-1$ route segments for the entire system. However, a person traveling from stop $i=1$ to stop $j=n$ has to wait while the bus makes $n-1$ stops.

\item You can have a special express bus from $i$ to $j$ for every stop $i$ to every other stop $j > i$. No person will ever have to make more than one stop.  However, this system requires $\Theta(n^2)$ route segments and will be expensive.
\end{enumerate}

Using divide-and-conquer, we will find a compromise solution that uses only $\Theta(n \log n)$ route segments, but with the property that a user can get from any stop $i$ to any stop $j > i$ making at most two stops in total.  That is, it should be possible to get from any $i$ to any $j > i$ either by taking a direct route $i \to j$ or by taking two routes $i \to m$ and $m \to j$.

\begin{enumerate}[label=(\alph*)]
\item  \textbf{[2 points]} For the base cases $n=1,2$, design a system using at most $1$ route segment.

\solution

n = 1: $o$ \\
n = 2: $o \longleftrightarrow o$ \\


\item  \textbf{[8 points]} For $n>2$ we will use divide-and-conquer. Assume that we already put in place routes connecting the first $n/2$ stops and routes connecting the last $n/2$ stops so that if $i$ and $j$ both belong to the same half, we can get from $i$ to $j$ in at most $2$ segments. Show how to add $O(n)$ additional route segments so that if $i$ is in the first half and $j$ is in the second half we can get from $i$ to $j$ making only two stops.

\solution \\ 
DRAWING ATTACHED

Given that both halfs are now full connected, we find the midpoint as the pivot, where all other stops have a non-stop segment that connects them to this midpoint.
This since each route will have a single segment, the total added segments will be $O(1n) = O(n)$

\item  \textbf{[4 points]} Using part (b), write (in pseudocode) a divide-and-conquer algorithm that takes as input the number of stops $n$ and outputs the list of all the route segments used by your bus system.

\solution

\lstinputlisting[language=Python]{1b.py}



\item  \textbf{[4 points]} Write the recurrence for the number of route segments your solution uses and solve it.  You may use any method for solving the recurrence that we have discussed in class.

\solution

Each call results in a successive loop, which adds n segments to the line, then proceeds to recursively call itselfs in both halves (n/2):\\
Thus, $T(n) = 2T(n/2) + n$ AND $T(1,2) = 1$ and can now be analyzed with the master theorem:\\
$a = 2, b= 2, d = 1, \frac{2}{2^1} = 1\rightarrow \Theta(n \log n) $


\end{enumerate}

\newpage

\begin{prob} Stop the Arsonist! (26 points) \end{prob}

Boston FD receives a letter from an arsonist. In the letter they find a list of $n$ words and a note that the building the arsonist plans to destroy is encoded within the list. The arsonist, who thinks he is clever, also provides a hint:

``The name of the building that I plan to destroy is the longest common prefix of all words in the attached list!"

Clearly, the arsonist is not very clever because (a) it is a terrible encoding and (b) he didn't think Boston FD had you to help them!

We will let $w_i$ be the i-th word in the list ($1 \leq i \leq n$) and $l(w_i)$ be the length of $w_i$ ($1 <= l(w_i) <= 25000~ \forall i$). We let $L$ be the max($l(w_i)$) over all $i$.

Your task is to determine the longest prefix of all words in the arsonist's list, before he destroys his target.


Here is an example:\\

The arsonist's list reads: ``northeasternkhouryccis", ``northeasternkhouryccisbuilding", ``northeasternkhouryyyyyyyy", ``northeasternkhourybuilding", ``northeasternkhourynortheastern"

\vspace{0.2cm}

The longest common prefix is ``northeasternkhoury".\\

\begin{enumerate}[label=(\alph*)]



\item \textbf{[10 points]} You want to show off your algorithmic prowess, and you realize that you can use divide-and-conquer to solve this problem.
 Design a divide-and-conquer algorithm that takes as input a list of $n$ words of maximum length $L$ and outputs the longest common prefix of the $n$ words in time $O(Ln)$. You should pseudocode for your algorithm, accompany this pseudocode with a written description, and provide justification for why it runs in $O(Ln)$ time. Note that you should treat $L$ as a variable, not as a constant.

(Hint: First develop an $O(L)$ algorithm for finding the longest common prefix of two words $a$ and $b$, then use this algorithm as part of your divide-and-conquer approach.)

\solution

\lstinputlisting[language=Python]{2a.py}


\item \textbf{[10 points]} In order to better your familiarity with divide-and-conquer algorithms, we have created a hackerrank challenge (\href{www.hackerrank.com/cs3000-summer1-2021-programming-assignment-2}{www.hackerrank.com/cs3000-summer1-2021-programming-assignment-2}). Please implement your divide-and-conquer strategy and submit it to the challenge. Your grade for this part will depend on (a) how many test cases your implementation passes and (b) actually implementing a divide-and-conquer strategy (we will check!).

In order to allow for efficient grading, please write your hackerrank account below.

\solution \\
$peter\_g$

\item \textbf{[3 points]} Your friend, who has no training in algorithms, proposes the following method for solving the problem when there are at least two words in the list ($n \geq 2$): Pick an arbitrary word and find the longest common prefix between it and each of the other $n-1$ words. Then look at this new list of $n-1$ common prefixes, and whichever is the shortest one, is the solution.  

What is the Big Oh runtime of your friend's approach (state in terms of $n$ and $L$)? Provide a short justification of your claim. To receive full marks, your runtime should be reasonably tight (i.e. relevant to the algorithm).

\solution

Runtime is $O(L(n-1)) + O(L(n-1)) = O(Ln) + O(Ln) = O(Ln)$ \\
The first $O(L(n-1))$ is from the initial comparison loop amongst all the words which initializes the list of prefixes. \\
The second is from finding the shortest prefix in the list of prefixes with would be size n -1 and up to L characters in length each at the worst case. :)
 

\item \textbf{[3 points]} Is your friend's algorithm correct? If yes, provide a proof of its correctness (\textbf{Hint:} I would use a combination of direction observations and contradiction, definitely avoiding induction!). If not, provide an instance of the problem where their approach does not work (\textbf{Hint:} I would think about relatively short lists of relatively short words).

\solution


This solution is correct: \\

Say we receive this list of words: \\
northeasternkhouryccis\\
northeasternkhouryccisbuilding\\
northeasternkhouryyyyyyyy\\
northeasternkhourybuilding\\
northeasternkhourynortheastern\\
northeastern \\

It is a guarantee that by checking an arbitrary word with the rest of the word bank that longest prefix will be found and added to the list. Then we can be certain that this would be the shortest word in the list is the true "longest common prefix" because the word that produced the shortest prefix would not have any of the longer prefixes by function design (which asserts that it will find the longest prefix common between the two words) otherwise it would have found that besides the shorter one. Therefore the shortest is the common prefix shared across all words as the longer words are only common amongst a subset of the words in the provided bank.

\end{enumerate}

\newpage

\begin{prob} A fault-tolerant OR-gate (14 points) \end{prob}


Assume you are given an infinite supply of two-input, one-output gates,
most of which are OR gates and some of which are AND gates. You may assume that all inputs are from the set $\{0, 1\}$. Recall that if at least one of the inputs to an OR gate is a 1, then the output is a 1, otherwise the output is a 0. If both inputs to an AND gate are 1s, then the output is a 1, otherwise the output is a 0.


The OR and AND gates have been mixed together and you
can't tell them apart.  For a given integer $k\geq 0$, you would like
to construct a two-input, one-output combinational ``$k$-OR'' circuit
from your supply of two-input, one output gates such that the following
property holds: If at most $k$ of the gates are AND gates then the
circuit correctly implements OR.   

Note that the inputs to a gate can either be the two ``circuit inputs" (which may be the inputs for multiple gates), or can be directed from the outputs of two other unique gates. There should be exactly one gate whose output is not directed to another gate, the output of which is returned by the circuit (is the circuit's output). A gate's output may be directed to more than one gate.

For a given integer $k \geq 0$, you would like to design a $k$-OR
circuit that uses as few gates as possible. Assume for simplicity that $k$ is a
power of two. Note that AND and OR gates only differ in their outputs when one input is a 1 and the other is a 0. It suffices to only consider the case where the ``circuit inputs" are a 1 and a 0.

\begin{enumerate}[label=(\alph*)]

\item \textbf{[4 points]}  Design a $1$-OR circuit with the smallest number of
  gates.  That is, your circuit should take two inputs (the ``circuit inputs"), and always
  return the OR of the inputs, as long as at most one of the gates
  constituting the circuit is an AND gate, while the remainder are OR
  gates.  Argue the correctness of your circuit.

\solution : In all alterations of a 1-OR regardless of the placement of the single AND gate, the circuit should operate as an OR --  Assume inputs are similar to attached drawing from 2a, gate rendering wasn't working too well.

\begin{circuitikz} \draw
(0,2) node[and port] (myand1) {}
(0,0) node[or port] (myand2) {}
(2,1) node[or port] (myxnor) {}
(myand1.out) -- (myxnor.in 1)
(myand2.out) -- (myxnor.in 2)
(myand2.in 1) -- (myand1.in 1)
(myand2.in 2) -- (myand1.in 2)
;
\end{circuitikz}

\begin{circuitikz} \draw
(0,2) node[or port] (myand1) {}
(0,0) node[and port] (myand2) {}
(2,1) node[or port] (myxnor) {}
(myand1.out) -- (myxnor.in 1)
(myand2.out) -- (myxnor.in 2)
(myand2.in 1) -- (myand1.in 1)
(myand2.in 2) -- (myand1.in 2)
;
\end{circuitikz}

\begin{circuitikz} \draw
(0,2) node[or port] (myand1) {}
(0,0) node[or port] (myand2) {}
(2,1) node[and port] (myxnor) {}
(myand1.out) -- (myxnor.in 1)
(myand2.out) -- (myxnor.in 2)
(myand2.in 1) -- (myand1.in 1)
(myand2.in 2) -- (myand1.in 2)
;
\end{circuitikz}


\item \textbf{[4 points]} Using a $1$-OR circuit as a black box,
  design a $2$-OR circuit.  How many gates does your circuit have?
  Argue the correctness of your circuit.

\solution \\
DRAWING ATTACHED


\item \textbf{[6 points]}  Generalizing the black box approach from part (b), design the best possible $k$-OR circuit
  you can and derive a $\Theta$-bound (in terms of the parameter $k$)
  for the number of gates in your $k$-OR circuit. Show your work for deriving this bound. For full credit, the number of gates
  in your circuit must be a polynomial in $k$.

\solution \\ 

The resulting circuit for k-OR will results in $3^k$ logic gates as shown in the illustration from 2b.

\end{enumerate}

\newpage
\begin{prob} Recurrences (10 points) \end{prob}
Suppose we have algorithms with running times $T(n)$ given by the recurrences:
\begin{enumerate}
\item $T(n) = 4T(n/2) + n^2$
\item $T(n) = T(n/2) + n$
\item $T(n) = 6T(n/25) + n^{1/2}$
\item $T(n) = 8T(n/2) + n^{3.5}$
\item $T(n) = 6T(n/10) + 4$
\end{enumerate}


Determine and state the asymptotic running time of each of these five algorithms, and then rank them in ascending order of their asymptotic running time.  You do not need to justify your ranking.

\solution

\begin{tabular}{|l|c|c|c|clclcl}
\hline
 a & b & d & $\frac{a}{b^d}$  & $>/</=$ & $T(n)$ \\
\hline
$4$ & $2$ & $2$ & $4/4$  & $= 1$ & $\Theta{n^2 \log n}$ \\
$1$ & $2$ & $1$ & $1/2$  & $< 1$ & $\Theta{n^{1/2}}$  \\
$6$ & $25$ & $1/2$ & $6/5$  & $> 1$ & $\Theta{n^{\log_{25} 6}}$\\
$8$ & $2$ & $3.5$ & $8/~11$  & $< 1$ & $\Theta{n^{3.5}}$ \\
$6$ & $10$ & $0$ & $6/1$   & $> 1$ & $\Theta{n^{\log_{10}6}}$  \\
\hline
\end{tabular}
\\\\
Ranking Order: $2, 3, 5, 4, 1$

\end{document}
